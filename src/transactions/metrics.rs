use alloy::primitives::Address;
use metrics::{Counter, Gauge, Histogram, counter, gauge, histogram};
use metrics_derive::Metrics;
use std::sync::Arc;

/// Metrics for a [`TransactionService`](crate::transactions::TransactionService).
#[derive(Metrics)]
#[metrics(scope = "transactions")]
pub struct TransactionServiceMetrics {
    /// Number of sent transactions.
    pub sent: Counter,
    /// Number of failed transactions.
    pub failed: Counter,
    /// Number of confirmed transactions
    pub confirmed: Counter,
    /// How many signers are currently active
    pub active_signers: Gauge,
    /// How many signers are currently paused
    pub paused_signers: Gauge,
    /// Number of pending transactions.
    pub pending: Gauge,
    /// Number of queued transactions.
    pub queued: Gauge,
    /// Number of times we've replaced transactions.
    pub replacements_sent: Counter,
    /// Number of timed out transactions.
    pub timed_out: Counter,
    /// Duration of polling the transaction service, in nanoseconds.
    pub poll_duration: Histogram,
    /// Number of intents that landed on chain and succeeded.
    pub successful_intents: Counter,
    /// Number of intents that landed on chain but failed.
    pub failed_intents: Counter,
    /// Number of transaction confirmations received from external provider.
    pub external_confirmations: Counter,
    /// Number of transaction confirmations received from local node provider.
    pub local_confirmations: Counter,
    /// Number of transaction confirmations received from flashblocks.
    pub flashblock_confirmations: Counter,
    /// Total time transaction took to land on chain, including time in queue.
    pub total_wait_time: Histogram,
    /// How many blocks were mined before the transaction was confirmed, including the block it was
    /// included in.
    pub blocks_until_inclusion: Histogram,
    /// How long transactions have spent in queue before being sent.
    pub time_in_queue: Histogram,
}

/// Metrics of an individual signer, should be labeled with the signer address and chain ID.
#[derive(derive_more::Deref, Debug)]
pub struct SignerMetrics {
    /// Reference to the [`TransactionServiceMetrics`].
    #[deref]
    pub tx_metrics: Arc<TransactionServiceMetrics>,
    /// Time it takes to include transactions, in milliseconds.
    pub confirmation_time: Histogram,
    /// Number of detected nonce gaps
    pub detected_nonce_gaps: Counter,
    /// Number of closed nonce gaps
    pub closed_nonce_gaps: Counter,
    /// Duration of polling the signer task, in nanoseconds.
    pub poll_duration: Histogram,
    /// Gas spent on transactions.
    pub gas_spent: Gauge,
    /// Native spent on transactions.
    pub native_spent: Gauge,
    /// Signer nonce.
    pub nonce: Counter,
}

impl SignerMetrics {
    /// Creates a new [`SignerMetrics`] for the given signer address and chain.
    pub fn new(
        tx_metrics: Arc<TransactionServiceMetrics>,
        address: Address,
        chain_id: u64,
    ) -> Self {
        Self {
            tx_metrics,
            confirmation_time: histogram!("signer.confirmation_time", "address" => address.to_string(), "chain_id" => chain_id.to_string()),
            detected_nonce_gaps: counter!("signer.detected_nonce_gaps", "address" => address.to_string(), "chain_id" => chain_id.to_string()),
            closed_nonce_gaps: counter!("signer.closed_nonce_gaps", "address" => address.to_string(), "chain_id" => chain_id.to_string()),
            poll_duration: histogram!("signer.poll_duration", "address" => address.to_string(), "chain_id" => chain_id.to_string()),
            gas_spent: gauge!("signer.gas_spent", "address" => address.to_string(), "chain_id" => chain_id.to_string()),
            native_spent: gauge!("signer.native_spent", "address" => address.to_string(), "chain_id" => chain_id.to_string()),
            nonce: counter!("signer.nonce", "address" => address.to_string(), "chain_id" => chain_id.to_string()),
        }
    }
}
